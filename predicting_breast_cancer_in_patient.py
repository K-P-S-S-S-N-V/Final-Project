# -*- coding: utf-8 -*-
"""predicting breast cancer in patient.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1P_lItRZMPPahWU19gCUJC4o89LN24gnk
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df=pd.read_csv("cancer.csv")
print(df)

df.isnull().sum()

display(df.iloc[4])

df.columns

df.drop(columns=['radius_se', 'texture_se', 'perimeter_se', 'area_se', 'smoothness_se',
       'compactness_se', 'concavity_se', 'concave points_se', 'symmetry_se',
       'fractal_dimension_se', 'radius_worst', 'texture_worst',
       'perimeter_worst', 'area_worst', 'smoothness_worst',
       'compactness_worst', 'concavity_worst', 'concave points_worst',
       'symmetry_worst', 'fractal_dimension_worst', 'Unnamed: 32'], inplace=True)

del df['id']
print(df)

df.describe()

Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR = Q3 - Q1
((df < (Q1 - 1.5 * IQR)) | (df > (Q3 + 1.5 * IQR))).sum() # gives no. of outliers

df = df.drop_duplicates()

x = df.loc[:,df.columns[1:]]
y = df['diagnosis']
y = y.map({'M':1, 'B':0})

!pip install sklearn

# Commented out IPython magic to ensure Python compatibility.
# %pip install scikit-learn

from sklearn.model_selection import train_test_split
x_train, x_test, y_train, y_test = train_test_split(x,y, test_size=0.30, random_state=4)

print("x_train-shape : ", x_train.shape)
print("y_train-shape : ", y_train.shape)
print("x_test-shape : ", x_test.shape)
print("y_test-shape : ", y_test.shape)

def capping(df,cols):
    for col in cols:
        Q1 = df[col].quantile(0.25)
        Q3 = df[col].quantile(0.75)
        IQR = Q3 - Q1
        Up=Q3 + (1.5 * IQR)
        Low=Q1 - (1.5 * IQR)
        
        df[col]=np.where(df[col]> Up,Up,np.where(df[col]<Low,Low,df[col]))

cols=x_train.columns
print(cols)

capping(x_train,cols)

x_train.describe()

Q1 = x_train.quantile(0.25)
Q3 = x_train.quantile(0.75)
IQR = Q3 - Q1
((x_train < (Q1 - 1.5 * IQR)) | (x_train > (Q3 + 1.5 * IQR))).sum()

from sklearn.preprocessing import StandardScaler

std = StandardScaler()

x_train = std.fit_transform(x_train)
x_test = std.transform(x_test)

#from sklearn import svm
from sklearn.svm import SVC

SVM = SVC(kernel='linear', gamma='scale')
SVM.fit(x_train, y_train)

y_pred = SVM.predict(x_test)
y_pred

df_new = pd.DataFrame({'True_Target': y_test, 'Predicted_target': y_pred})
df_new

from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

cnf_matrix_test = confusion_matrix(y_test, y_pred)
ConfusionMatrixDisplay(confusion_matrix=cnf_matrix_test, display_labels=SVM.classes_).plot()

from sklearn.metrics import confusion_matrix, accuracy_score
accuracy = accuracy_score(y_test, y_pred)
cm = confusion_matrix(y_test, y_pred)
print(cm)
print("The model accuracy is", accuracy )

group_names = ["True Pos","False Pos","False Neg","True Neg"]
group_counts = ["{0:0.0f}".format(value) for value in cm.flatten()]
group_percentages = ["{0:.2%}".format(value) for value in cm.flatten()/np.sum(cm)]
labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in zip(group_names, group_counts, group_percentages)]
labels = np.asarray(labels).reshape(2,2)

sns.heatmap(cm, annot=labels, fmt="", cmap='Blues')

from sklearn.metrics import classification_report
predictions = SVM.predict(x_test)
print(classification_report(y_test, predictions))

from sklearn.model_selection import GridSearchCV
# defining parameter range
param_grid = {'C': [0.1, 0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0], 
              'gamma': [1, 0.1, 0.01, 0.001, 0.0001],
              'kernel': ['rbf']} 
 #refitting i to find the best parameter cobination fist with cross vvalidation and again without cross validation. 
grid = GridSearchCV(SVC(), param_grid, refit = True, verbose = 3) 
  
# fitting the model for grid search
grid.fit(x_train, y_train)

print(grid.best_params_)
print(grid.best_estimator_)

grid_predictions = grid.predict(x_test)
print(classification_report(y_test, grid_predictions))

cm = confusion_matrix(y_test, grid_predictions)

group_names = ["True Pos","False Pos","False Neg","True Neg"]
group_counts = ["{0:0.0f}".format(value) for value in cm.flatten()]
group_percentages = ["{0:.2%}".format(value) for value in cm.flatten()/np.sum(cm)]
labels = [f"{v1}\n{v2}\n{v3}" for v1, v2, v3 in zip(group_names, group_counts, group_percentages)]
labels = np.asarray(labels).reshape(2,2)

sns.heatmap(cm, annot=labels, fmt="", cmap='Blues')

df.iloc[3]. values. tolist()

input_data = (11.42,
 20.38,
 77.58,
 386.1,
 0.1425,
 0.2839,
 0.2414,
 0.1052,
 0.2597,
 0.09744)
input_data_as_numpy_array = np.asarray(input_data)
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

prediction = SVM.predict(input_data_reshaped)
print(prediction)

if (prediction[0] == 0):
  print('The person is cancer-free')
else:
  print('The person has cancer')

import pickle

filename = 'breast_cancer_trained_model.sav'
pickle.dump(SVM, open(filename, 'wb'))
loaded_model = pickle.load(open('breast_cancer_trained_model.sav', 'rb'))

input_data = (11.42,
 20.38,
 77.58,
 386.1,
 0.1425,
 0.2839,
 0.2414,
 0.1052,
 0.2597,
 0.09744)
input_data_as_numpy_array = np.asarray(input_data)
input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)

prediction = SVM.predict(input_data_reshaped)
print(prediction)

if (prediction[0] == 0):
  print('The person is cancer-free')
else:
  print('The person has cancer')

df.columns

!pip install streamlit

import numpy as np
import pickle
import streamlit as st

loaded_model = pickle.load(open('breast_cancer_trained_model.sav', 'rb'))

def cancer_prediction(input_data):
        
    input_data_as_numpy_array = np.asarray(input_data)

    input_data_reshaped = input_data_as_numpy_array.reshape(1,-1)
    
    prediction = loaded_model.predict(input_data_reshaped)
    print(prediction)

    if (prediction[0] == 0):
      return 'The person is cancer-free'
    else:
      return 'The person has cancer'
def main(): 
    st.title('Breast cancer Prediction Web App')
    radius_mean =st.text_input('radius')
    texture_mean =st.text_input('texture')
    perimeter_mean=st.text_input('perimeter')
    area_mean=st.text_input('area')
    smoothness_mean=st.text_input('smoothness')
    compactness_mean=st.text_input('compactness')
    concavity_mean=st.text_input('concavity')
    concave_points_mean=st.text_input('concave points')
    symmetry_mean=st.text_input('Symmetry')
    fractal_dimension_mean=st.text_input('fractal dimension')
    
    diagnosis = ''
    if st.button('Cancer Test Result'):
        diagnosis = cancer_prediction([radius_mean, texture_mean, perimeter_mean,area_mean, smoothness_mean, compactness_mean, concavity_mean,
       concave_points_mean, symmetry_mean, fractal_dimension_mean])
              
    st.success(diagnosis)
      
if __name__ == '__main__':
    main()